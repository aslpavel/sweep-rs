use crate::{
    Candidate, FieldSelector, FuzzyScorer, Haystack, RPCErrorKind, RPCRequest, Ranker,
    RankerResult, ScoreResult, ScorerBuilder,
};
use anyhow::Error;
use crossbeam_channel::{unbounded, Receiver, Sender};
use serde_json::Value;
use std::{
    io::Write,
    ops::Deref,
    sync::Arc,
    thread::{Builder, JoinHandle},
    time::{Duration, Instant},
};
use surf_n_term::{
    widgets::{Input, List, ListItems, Theme},
    Blend, Color, DecMode, Face, FaceAttrs, Key, KeyMap, KeyMod, KeyName, Position, Surface,
    SurfaceMut, SystemTerminal, Terminal, TerminalAction, TerminalCommand, TerminalEvent,
    TerminalSurfaceExt, TerminalWaker, TerminalWritable, TerminalWriter,
};

pub struct SweepOptions {
    pub height: usize,
    pub prompt: String,
    pub theme: Theme,
    pub keep_order: bool,
    pub tty_path: String,
    pub title: String,
    pub scorer_builder: ScorerBuilder,
    pub altscreen: bool,
}

impl Default for SweepOptions {
    fn default() -> Self {
        Self {
            height: 11,
            prompt: "INPUT".to_string(),
            theme: Theme::light(),
            keep_order: false,
            tty_path: "/dev/tty".to_string(),
            title: "sweep".to_string(),
            scorer_builder: Arc::new(|niddle: &str| {
                let niddle: Vec<_> = niddle.chars().flat_map(char::to_lowercase).collect();
                Arc::new(FuzzyScorer::new(niddle))
            }),
            altscreen: false,
        }
    }
}

/// Simple sweep function when you just need to select single entry from the list
pub fn sweep<H, HS>(options: SweepOptions, haystack: HS) -> Result<Option<H>, Error>
where
    HS: IntoIterator,
    H: Haystack + From<HS::Item>,
{
    let sweep = Sweep::new(options)?;
    sweep.haystack_extend(haystack);
    for event in sweep.events().iter() {
        if let SweepEvent::Select(entry) = event {
            return Ok(Some(entry));
        }
    }
    Ok(None)
}

enum SweepCommand {
    NiddleSet(String),
    PromptSet(String),
    Bind(Vec<Key>, Value),
    Terminate,
    Current,
}
#[derive(Clone, Debug)]
pub enum SweepEvent<H> {
    Select(H),
    Bind(Value),
}

#[derive(Clone, Debug)]
pub enum SweepResponse<H> {
    Current(Option<H>),
}

#[derive(Clone)]
pub struct Sweep<H>
where
    H: Haystack,
{
    inner: Arc<SweepInner<H>>,
}

impl<H: Haystack> Deref for Sweep<H> {
    type Target = SweepInner<H>;

    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

impl<H> Sweep<H>
where
    H: Haystack,
{
    pub fn new(options: SweepOptions) -> Result<Self, Error> {
        let inner = Arc::new(SweepInner::new(options)?);
        Ok(Sweep { inner })
    }

    fn send_command(&self, command: SweepCommand) {
        self.commands
            .send(command)
            .expect("failed to send command to sweep_worker");
        self.waker.wake().expect("failed to wake terminal");
    }

    /// Extend haystack with entries
    pub fn haystack_extend<HS>(&self, haystack: HS)
    where
        HS: IntoIterator,
        H: From<HS::Item>,
    {
        self.ranker
            .haystack_extend(haystack.into_iter().map(From::from).collect())
    }

    /// Remove all entries from the haystack
    pub fn haystack_clear(&self) {
        self.ranker.haystack_clear()
    }

    pub fn haystack_reverse(&self) {
        self.ranker.haystack_reverse()
    }

    /// Set niddle to the spcified string
    pub fn niddle_set(&self, niddle: impl AsRef<str>) {
        self.send_command(SweepCommand::NiddleSet(niddle.as_ref().to_string()))
    }

    /// Set scorer used for ranking
    pub fn scorer_set(&self, scorer: ScorerBuilder) {
        self.ranker.scorer_set(scorer)
    }

    pub fn prompt_set(&self, prompt: String) {
        self.send_command(SweepCommand::PromptSet(prompt))
    }

    pub fn current(&self) -> Result<Option<H>, Error> {
        self.send_command(SweepCommand::Current);
        let SweepResponse::Current(current) = self.response.recv()?;
        Ok(current)
    }

    /// Bind specified chord to the tag
    ///
    /// Whenever sequence of keys specified by chord is pressed, `SweepEvent::Bind(tag)`
    /// will be generated, not if tag is `Value::Null` the binding will be removed
    /// and not event will be generated.
    pub fn bind(&self, chord: Vec<Key>, tag: Value) {
        self.send_command(SweepCommand::Bind(chord, tag))
    }

    /// Event generated by the `Sweep` object
    pub fn events(&self) -> &Receiver<SweepEvent<H>> {
        &self.events
    }
}

pub struct SweepInner<H: Haystack> {
    ranker: Ranker<H>,
    waker: TerminalWaker,
    worker: Option<JoinHandle<Result<(), Error>>>,
    commands: Sender<SweepCommand>,
    response: Receiver<SweepResponse<H>>,
    events: Receiver<SweepEvent<H>>,
}

impl<H: Haystack> SweepInner<H> {
    pub fn new(options: SweepOptions) -> Result<Self, Error> {
        let (commands_send, commands_recv) = unbounded();
        let (events_send, events_recv) = unbounded();
        let (response_send, response_recv) = unbounded();
        let term = SystemTerminal::open(&options.tty_path)?;
        let waker = term.waker();
        let ranker = Ranker::new(options.scorer_builder.clone(), options.keep_order, {
            let waker = waker.clone();
            move || waker.wake().is_ok()
        });
        let worker = Builder::new().name("sweep_worker".to_string()).spawn({
            let ranker = ranker.clone();
            move || {
                sweep_worker(
                    options,
                    term,
                    ranker,
                    commands_recv,
                    response_send,
                    events_send,
                )
            }
        })?;
        Ok(SweepInner {
            ranker,
            waker,
            worker: Some(worker),
            commands: commands_send,
            response: response_recv,
            events: events_recv,
        })
    }
}

impl<H> Drop for SweepInner<H>
where
    H: Haystack,
{
    fn drop(&mut self) {
        self.commands.send(SweepCommand::Terminate).unwrap_or(());
        self.waker.wake().unwrap_or(());
        if let Some(handle) = self.worker.take() {
            if let Err(error) = handle.join() {
                eprintln!("sweep worker thread fail:\r\n{:?}", error);
            }
        }
    }
}

impl Sweep<Candidate> {
    pub fn process_request(
        &self,
        mut request: RPCRequest,
        delimiter: char,
        field_selector: Option<&FieldSelector>,
    ) -> Option<Value> {
        let params = request.params.take();
        let result = match request.method.as_ref() {
            "haystack_extend" => {
                let items = if let Value::Array(items) = params {
                    items
                } else {
                    let error = request.response_err(
                        RPCErrorKind::InvalidParams,
                        Some("[haystack_extend] parameters must be an array"),
                    );
                    return Some(error);
                };
                let mut candidates = Vec::new();
                for item in items {
                    match Candidate::from_json(item, delimiter, field_selector) {
                        Some(candidate) => candidates.push(candidate),
                        None => {
                            let error = request.response_err(
                                RPCErrorKind::InvalidParams,
                                Some("[haystack_extend] item must be a string or an object with \"string\" field"),
                            );
                            return Some(error);
                        }
                    }
                }
                self.haystack_extend(candidates);
                Value::Null
            }
            "haystack_clear" => {
                self.haystack_clear();
                Value::Null
            }
            "niddle_set" => {
                if let Value::String(niddle) = params {
                    self.niddle_set(niddle);
                    Value::Null
                } else {
                    let error = request.response_err(
                        RPCErrorKind::InvalidParams,
                        Some("[niddle_set] parameters must be a string"),
                    );
                    return Some(error);
                }
            }
            "terminate" => {
                self.send_command(SweepCommand::Terminate);
                Value::Null
            }
            "key_binding" => {
                let mut obj = if let Value::Object(obj) = params {
                    obj
                } else {
                    let error = request.response_err(
                        RPCErrorKind::InvalidParams,
                        Some("[key_binding] parameters must be an object"),
                    );
                    return Some(error);
                };
                let key = if let Some(Value::String(key)) = obj.get_mut("key") {
                    match Key::chord(key) {
                        Ok(key) => key,
                        Err(error) => {
                            let error = request.response_err(
                                RPCErrorKind::InvalidParams,
                                Some(format!(
                                    "[key_binding] failed to parse key attribute: {}",
                                    error
                                )),
                            );
                            return Some(error);
                        }
                    }
                } else {
                    let error = request.response_err(
                        RPCErrorKind::InvalidParams,
                        Some("[key_binding] \"key\" attribute must be present and be a string"),
                    );
                    return Some(error);
                };
                let tag = if let Some(tag) = obj.get_mut("tag") {
                    tag.take()
                } else {
                    let error = request.response_err(
                        RPCErrorKind::InvalidParams,
                        Some("[key_binding] \"tag\" attribute must be present"),
                    );
                    return Some(error);
                };
                self.bind(key, tag);
                Value::Null
            }
            "prompt_set" => {
                if let Value::String(prompt) = params {
                    self.prompt_set(prompt);
                    Value::Null
                } else {
                    let error = request.response_err(
                        RPCErrorKind::InvalidParams,
                        Some("[prompt_set] parameters must be a string"),
                    );
                    return Some(error);
                }
            }
            "current" => match self.current() {
                Ok(current) => {
                    current.map_or_else(|| Value::Null, |current| current.to_string().into())
                }
                Err(error) => {
                    let error =
                        request.response_err(RPCErrorKind::InternalError, Some(error.to_string()));
                    return Some(error);
                }
            },
            method => {
                let error_data = Some(format!("unknown method: {}", method));
                let error = request.response_err(RPCErrorKind::MethodNotFound, error_data);
                return Some(error);
            }
        };
        request.response_ok(result)
    }
}

fn sweep_worker<H>(
    options: SweepOptions,
    mut term: SystemTerminal,
    ranker: Ranker<H>,
    commands: Receiver<SweepCommand>,
    response: Sender<SweepResponse<H>>,
    events: Sender<SweepEvent<H>>,
) -> Result<(), Error>
where
    H: Haystack,
{
    // colors
    let debug_face: Face = "bg=#cc241d,fg=#ebdbb2".parse()?;
    let stats_face = Face::new(
        Some(
            options
                .theme
                .accent
                .best_contrast(options.theme.bg, options.theme.fg),
        ),
        Some(options.theme.accent),
        FaceAttrs::EMPTY,
    );
    let label_face = stats_face.with_attrs(FaceAttrs::BOLD);
    let separator_face = Face::new(
        Some(options.theme.accent),
        options.theme.input.bg,
        FaceAttrs::EMPTY,
    );

    // initialize terminal
    term.execute(TerminalCommand::DecModeSet {
        enable: false,
        mode: DecMode::VisibleCursor,
    })?;
    term.execute(TerminalCommand::Title(options.title.clone()))?;
    if options.altscreen {
        term.execute(TerminalCommand::DecModeSet {
            enable: true,
            mode: DecMode::AltScreen,
        })?;
    }

    // find current row offset
    let mut row_offset = 0;
    let height = options.height;
    term.execute(TerminalCommand::CursorGet)?;
    while let Some(event) = term.poll(None)? {
        if let TerminalEvent::CursorPosition { row, .. } = event {
            row_offset = row;
            break;
        }
    }
    let term_size = term.size()?;
    if height > term_size.cells.height {
        row_offset = 0;
    } else if row_offset + height > term_size.cells.height {
        let scroll = row_offset + height - term_size.cells.height;
        row_offset = term_size.cells.height - height;
        term.execute(TerminalCommand::Scroll(scroll as i32))?;
    }

    // initialize widgets
    let mut input = Input::new();
    let mut list = List::new(RankerResultThemed::new(
        options.theme.clone(),
        Arc::new(RankerResult::<H>::default()),
    ));
    let mut prompt = options.prompt.clone();

    // key bindings
    let mut key_map = KeyMap::new();
    let mut key_map_state = Vec::new();

    // render loop
    term.waker().wake()?; // schedule one wake just in case if it was consumed by previous poll
    let result = term.run_render(|term, event, view| -> Result<TerminalAction<()>, Error> {
        let frame_start = Instant::now();

        // handle events
        if let Some(event) = &event {
            match *event {
                TerminalEvent::Key(Key { name, mode }) if mode == KeyMod::CTRL => {
                    if name == KeyName::Char('c') {
                        return Ok(TerminalAction::Quit(()));
                    } else if name == KeyName::Char('m') || name == KeyName::Char('j') {
                        if let Some(result) = list.current() {
                            events.send(SweepEvent::Select(result.result.haystack))?
                        }
                    }
                }
                TerminalEvent::Key(Key {
                    name: KeyName::Esc,
                    mode: KeyMod::EMPTY,
                }) => {
                    return Ok(TerminalAction::Quit(()));
                }
                TerminalEvent::Resize(_term_size) => {
                    term.execute(TerminalCommand::Scroll(row_offset as i32))?;
                    row_offset = 0;
                }
                TerminalEvent::Wake => {
                    for command in commands.try_iter() {
                        match command {
                            SweepCommand::NiddleSet(niddle) => input.set(niddle.as_ref()),
                            SweepCommand::Terminate => return Ok(TerminalAction::Quit(())),
                            SweepCommand::Bind(chord, tag) => {
                                key_map.register(chord.as_ref(), tag);
                            }
                            SweepCommand::PromptSet(new_prompt) => {
                                prompt = new_prompt;
                            }
                            SweepCommand::Current => {
                                let current =
                                    list.current().map(|candidate| candidate.result.haystack);
                                response.send(SweepResponse::Current(current))?;
                            }
                        }
                    }
                }
                _ => (),
            }
            if let TerminalEvent::Key(key) = *event {
                if let Some(tag) = key_map.lookup_state(&mut key_map_state, key) {
                    // only gnerate event
                    // - if it is not a Backspace, when input is not empty
                    // - tag is not Value::Null
                    if key != Key::new(KeyName::Backspace, KeyMod::EMPTY)
                        || input.get().count() == 0 && !tag.is_null()
                    {
                        events.send(SweepEvent::Bind(tag.clone()))?;
                    }
                }
            }

            input.handle(event);
            list.handle(event);
        }
        // restrict view
        let mut view = view.view_owned((row_offset as i32).., 1..-1);

        // update niddle
        ranker.niddle_set(input.get().collect());
        let ranker_result = ranker.result();

        // label
        let mut label_view = view.view_mut(0, ..);
        let mut label = label_view.writer().face(label_face);
        write!(&mut label, " {} ", prompt)?;
        let mut label = label.face(separator_face);
        write!(&mut label, " ")?;
        let input_start = label.position().1 as i32;

        // stats
        let stats_str = format!(
            " {}/{} {:.2?} [{}] ",
            ranker_result.result.len(),
            ranker_result.haystack_size,
            ranker_result.duration,
            ranker_result.scorer.name(),
        );
        let input_stop = -(stats_str.chars().count() as i32 + 1);
        let mut stats_view = view.view_mut(0, input_stop..);
        let mut stats = stats_view.writer().face(separator_face);
        write!(&mut stats, "")?;
        let mut stats = stats.face(stats_face);
        stats.write_all(stats_str.as_ref())?;

        // input
        input.render(&options.theme, view.view_mut(0, input_start..input_stop))?;

        // list
        if list.items().generation() != ranker_result.generation {
            let old_result = list.items_set(RankerResultThemed::new(
                options.theme.clone(),
                ranker_result,
            ));
            // dropping old result might add noticeable delay for large lists
            rayon::spawn(move || std::mem::drop(old_result));
        }
        list.render(&options.theme, view.view_mut(1..height as i32, ..))?;

        if false {
            let frame_time = Instant::now() - frame_start;
            let debug_height = (height as i32 + 1)..(height as i32 + 7);
            let mut debug = view.view_mut(debug_height, ..);
            debug.erase(debug_face.bg);
            let mut debug_writer = debug.writer().face(debug_face);
            writeln!(&mut debug_writer, "row: {}", row_offset)?;
            writeln!(&mut debug_writer, "frame_time: {:?}", frame_time)?;
            writeln!(&mut debug_writer, "event: {:?}", event)?;
            writeln!(&mut debug_writer, "term: {:?}", term.stats())?;
            writeln!(
                &mut debug_writer,
                "current: {:?}",
                list.current().map(|r| r.result)
            )?;
        }

        Ok(TerminalAction::Wait)
    });

    // restore terminal
    term.execute(TerminalCommand::CursorTo(Position {
        row: row_offset,
        col: 0,
    }))?;
    if options.altscreen {
        term.execute(TerminalCommand::DecModeSet {
            enable: false,
            mode: DecMode::AltScreen,
        })?;
    }
    term.poll(Some(Duration::new(0, 0)))?;
    std::mem::drop(term);

    let _ = result?;

    Ok(())
}

#[derive(Debug)]
struct ScoreResultThemed<H> {
    result: ScoreResult<H>,
    face_default: Face,
    face_inactive: Face,
    face_highlight: Face,
}

impl<H: Haystack> TerminalWritable for ScoreResultThemed<H> {
    fn fmt(&self, writer: &mut TerminalWriter<'_>) -> std::io::Result<()> {
        let mut index = 0;
        for field in self.result.haystack.fields() {
            match field {
                Err(field) => {
                    writer.face_set(self.face_inactive);
                    writer.write_all(field.as_ref())?;
                    writer.face_set(self.face_default);
                }
                Ok(field) => {
                    for c in field.chars() {
                        if self.result.positions.contains(&index) {
                            writer.put_char(c, self.face_highlight);
                        } else {
                            writer.put_char(c, self.face_default);
                        }
                        index += 1;
                    }
                }
            }
        }
        Ok(())
    }

    fn height_hint(&self, width: usize) -> Option<usize> {
        let mut length = 0;
        for field in self.result.haystack.fields() {
            let field = match field {
                Ok(field) => field,
                Err(field) => field,
            };
            for c in field.chars() {
                length += match c {
                    '\n' => width - length % width,
                    _ => 1,
                }
            }
        }
        Some(length / width + (if length % width != 0 { 1 } else { 0 }))
    }
}

struct RankerResultThemed<H> {
    theme: Theme,
    ranker_result: Arc<RankerResult<H>>,
}

impl<H> RankerResultThemed<H> {
    fn new(theme: Theme, ranker_result: Arc<RankerResult<H>>) -> Self {
        Self {
            theme,
            ranker_result,
        }
    }

    fn generation(&self) -> usize {
        self.ranker_result.generation
    }
}

impl<H: Clone + Haystack> ListItems for RankerResultThemed<H> {
    type Item = ScoreResultThemed<H>;

    fn len(&self) -> usize {
        self.ranker_result.result.len()
    }

    fn get(&self, index: usize) -> Option<Self::Item> {
        let face_default = Face::default().with_fg(Some(self.theme.fg));
        let face_inactive = Face::default().with_fg(Some(
            self.theme
                .bg
                .blend(self.theme.fg.with_alpha(0.6), Blend::Over),
        ));
        self.ranker_result
            .result
            .get(index)
            .map(|result| ScoreResultThemed {
                result: result.clone(),
                face_default,
                face_inactive,
                face_highlight: self.theme.cursor,
            })
    }
}
